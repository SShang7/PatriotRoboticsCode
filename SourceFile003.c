#pragma config(Sensor, in1,    stopper,        sensorLineFollower)
#pragma config(Sensor, in2,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  fly,            sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftencoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  rightencoder,   sensorQuadEncoder)
#pragma config(Motor,  port1,           r1,            tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           leftfly,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           rightfly,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           indexer,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           l2,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           r2,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           roller,        tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,            ,             tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           descorer,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          l1,            tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*																																					 */
/*				Description: Competition template for VEX EDR											 */
/*																																					 */
/*---------------------------------------------------------------------------*/
//numbers that correspond with the button on lcd
const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;
int count = 0;
void waitForPress()
{
	while(nLCDButtons == 0){}
	bLCDBacklight=true;
	wait1Msec(5);
}
//----------------------------------------------------------------

//Wait for Release------------------------------------------------
void waitForRelease()
{
	while(nLCDButtons != 0){}
	wait1Msec(5);
}



float kpDrive = 0.093;
float kiDrive = 2.5;

float gyroturnp = 0.08;
float gyroturnd = 0.18;


int targetAngleDrive = 0;


int errorDriveLeft = 0;
int errorDriveRight = 0;

int targetDriveLeft = 0; //target = current value: sets motors to 0 unless direct otherwise
int targetDriveRight = 0; //target = current value: sets motors to 0 unless direct otherwise


int errorTurn = 0;
int targetTurn = 0;
float turnK = 0.6;


int gyrolasterror = 0;
int gyroderivative = 0;

int gyrocurrenterror = 0;
int targetgyroturn = 0;





volatile int lastrpm;
volatile int actualrpm;
bool flywheelstate;
volatile int goalvelocity;
volatile int shootingpower;

volatile int lastshoterror;
volatile int shoterror;

float kp = 2;
float kd = 0.3;





// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"


task rpm(){
	int rpmold;

	while(true)
	{
		rpmold = abs(SensorValue[fly]);
		wait1Msec(80);
		//	rpmnew = sensorValue[fly];

		actualrpm = abs(SensorValue[fly]) - rpmold;
		SensorValue[fly]=0;

	}

}



void shoot(int power){
	motor[leftfly]=power;
	motor[rightfly]=power;



}




task flywheelbang(){
	while(true){

	if (flywheelstate == true){

		if (goalvelocity > actualrpm){
		shoot(110);

		}else{
		shoot(70);


	}

	}else{
	shoot(0);
}
}
}

task intakein(){
	while(true){


			if(sensorValue[stopper] > 2900){

				motor[indexer]=80;
				motor[roller]=127;

				}else{

				motor[indexer]=-10;
				motor[roller]=127;

			}

		}
}

task intakeout(){
	while(true){
	motor[indexer]=-127;
	motor[roller]=-127
}

}

task intakestop(){
	while(true){
	motor[indexer]=0;
	motor[roller]=0;

}

}

task shooting(){
	while(true){
		motor[indexer]=motor[roller]=127;


}

}

task drivePID() //drive PID control
{


	while(true)
	{


    errorDriveLeft = targetDriveLeft - SensorValue(leftencoder);//find error between target and actual
		//errorDriveRight = targetDriveRight - SensorValue(rightencoder);


		motor[l1] = motor[l2] = errorDriveLeft*kpDrive ;
		motor[r1] = motor[r2] = -errorDriveLeft*kpDrive ;

		//and set motor accordingly

		delay(25);
	}
}

void setDrive(int setleft){
	targetDriveLeft = setleft;

};

void clearDrive(){
	sensorValue[leftencoder]=0


}


task gyroturnPID() //drive PID control
{
	sensorValue[gyro]=0;
	while(true)
	{
		gyrocurrenterror = targetgyroturn - SensorValue[gyro] ; //find error between target and actual

		gyroderivative = gyrocurrenterror - gyrolasterror;

		gyrolasterror = gyrocurrenterror;

		motor(r1) = motor(r2) = motor(l1) = motor(l2)= -(gyrocurrenterror*gyroturnp + gyroderivative*gyroturnd); //and set motor accordingly

		wait1Msec(20);
	}
}

void setgyroturn(int target){

targetgyroturn = target;

}


void cleargyroturn(){
	sensorValue[gyro]=0;

}








/*---------------------------------------------------------------------------*/
/*													Pre-Autonomous Functions												 */
/*																																					 */
/*	You may want to perform some actions before the competition starts.			 */
/*	Do them in the following function.	You must return from this function	 */
/*	or the autonomous and usercontrol tasks will not be started.	This			 */
/*	function is only called once after the cortex has been powered on and		 */
/*	not every time that the robot is disabled.															 */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
		clearLCDLine(0);
	clearLCDLine(1);
	//Loop while center button is not pressed
	while((nLCDButtons != centerButton))
	{
		//Switch case that allows the user to choose from 4 different options
		switch(count){
		case 0:
			//Display first choice
			displayLCDCenteredString(0, "Red Front");
			displayLCDCenteredString(1, "<   Enter   >");
			waitForPress();

			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count = 4;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 1:
			//Display second choice
			displayLCDCenteredString(0, "Red Back");
			displayLCDCenteredString(1, "<   Enter   >");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 2:
			//Display third choice
			displayLCDCenteredString(0, "Blue Front");
			displayLCDCenteredString(1, "<   Enter   >");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 3:
			//Display fourth choice
			displayLCDCenteredString(0, "Blue Back");
			displayLCDCenteredString(1, "<   Enter   >");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 4:
			//Display fourth choice
			displayLCDCenteredString(0, "Do nothing");
			displayLCDCenteredString(1, "<   Enter   >");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 5:
			//Display fourth choice
			displayLCDCenteredString(0, "N/A");
			displayLCDCenteredString(1, "<   Enter   >");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count = 0;
			}
			break;
		case 6:
			//Display fourth choice
			displayLCDCenteredString(0, "N/A");
			displayLCDCenteredString(1, "<   Enter   >");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count = 0;
			}
			break;
		default:
			count = 0;
			break;
		}
	}
}


/*---------------------------------------------------------------------------*/
/*																																					 */
/*															Autonomous Task															 */
/*																																					 */
/*	This task is used to control your robot during the autonomous phase of	 */
/*	a VEX Competition.																											 */
/*																																					 */
/*	You must modify the code to add your own robot specific commands here.	 */
/*---------------------------------------------------------------------------*/

task autonomous()
{
clearLCDLine(0);
	clearLCDLine(1);
	//Switch Case that actually runs the user choice
	switch(count){
	case 0:
		//If count = 0, run the code correspoinding with choice 1
		displayLCDCenteredString(0, "Red Front");
		displayLCDCenteredString(1, "is running!");

flywheelstate=true;
goalvelocity = 390;
startTask(rpm);
startTask(flywheelbang);


clearDrive();
	startTask(drivePID);

	startTask(intakein);
	setDrive(960);
	wait1Msec(2000);
	clearDrive();
	setDrive(-1150);
	wait1Msec(2000);
	stopTask(drivePID);
	startTask(gyroturnPID);
	setgyroturn(1000); //turn to shoot
	wait1Msec(600);

  stopTask(gyroturnPID);
	startTask(drivePID);
	clearDrive();
	setDrive(360);
	wait1Msec(500);


	stopTask(intakein);
	startTask(shooting);
	wait1Msec(300);
	stopTask(shooting);
	startTask(intakein);
	stopTask(gyroturnPID);
	startTask(drivePID);
	clearDrive();
	setDrive(700);
	wait1Msec(700);
	stopTask(intakein);
	startTask(shooting);
	wait1Msec(300);
	stopTask(drivePID);
	cleargyroturn()
	startTask(gyroturnPID);
	setgyroTurn(350);
	wait1Msec(500);
	stopTask(gyroturnPID);
	startTask(drivePID)
	stopTask(intakein);


	clearDrive();
	setDrive(780);


		break;

	case 1:
		//If count = 1, run the code correspoinding with choice 2
		displayLCDCenteredString(0, "Red Back");
		displayLCDCenteredString(1, "is running!");
startTask(rpm);
startTask(flywheelbang);
flywheelstate=true;
goalvelocity=325;
wait1Msec(6000);
startTask(shooting);
wait1Msec(1000);
stopTask(shooting);
clearDrive();
startTask(drivePID);
setDrive(2800);
wait1Msec(5000);
stopTask(drivePID);

		break;
	case 2:
		//If count = 2, run the code correspoinding with choice 3
		displayLCDCenteredString(0, "Blue Front");
		displayLCDCenteredString(1, "is running!");

flywheelstate=true;
goalvelocity = 390;
startTask(rpm);
startTask(flywheelbang);


clearDrive();
	startTask(drivePID);

	startTask(intakein);
	setDrive(960);
	wait1Msec(2000);
	clearDrive();
	setDrive(-990);
	wait1Msec(2000);
	stopTask(drivePID);
	startTask(gyroturnPID);
	setgyroturn(-1070); //turn to shoot
	wait1Msec(600);

  stopTask(gyroturnPID);
	startTask(drivePID);
	clearDrive();
	setDrive(360);
	wait1Msec(500);


	stopTask(intakein);
	startTask(shooting);
	wait1Msec(300);
	stopTask(shooting);
	startTask(intakein);
	stopTask(gyroturnPID);
	startTask(drivePID);
	clearDrive();
	setDrive(700);
	wait1Msec(700);
	stopTask(intakein);
	startTask(shooting);
	wait1Msec(300);
	stopTask(drivePID);
	cleargyroturn()
	startTask(gyroturnPID);
	setgyroTurn(-350);
	wait1Msec(500);
	stopTask(gyroturnPID);
	stopTask(intakein);
	startTask(drivePID)

	clearDrive();
	setDrive(800);


		break;
	case 3:
startTask(rpm);
startTask(flywheelbang);
flywheelstate=true;
goalvelocity=325;
wait1Msec(6000);
startTask(shooting);
wait1Msec(1000);
stopTask(shooting);


		break;
		//If count = 3, run the code correspoinding with choice 4
		displayLCDCenteredString(0, "Blue Back");
		displayLCDCenteredString(1, "is running!");



		break;
	case 4:
		displayLCDCenteredString(0, "N/A");
		displayLCDCenteredString(1, "is running!");





		break;
	case 5:
		displayLCDCenteredString(0, "N/A");
		displayLCDCenteredString(1, "is running!");


		break;
	case 6:
		//If count = 1, run the code correspoinding with choice 2
		displayLCDCenteredString(0, "N/A");
		displayLCDCenteredString(1, "is running!");



		break;

	default:
		displayLCDCenteredString(0, "No valid choice");
		displayLCDCenteredString(1, "was made!");
		break;
	}







}

/*---------------------------------------------------------------------------*/
/*																																					 */
/*															User Control Task														 */
/*																																					 */
/*	This task is used to control your robot during the user control phase of */
/*	a VEX Competition.																											 */
/*																																					 */
/*	You must modify the code to add your own robot specific commands here.	 */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
	// User control code here, inside the loop
	startTask(rpm);

	while (true){
		startTask(flywheelbang);





		// two stick arcade

		motor(l1) = motor(l2) = vexRT(Ch3) + vexRT(Ch1);
		motor(r1) = motor(r2) = -vexRT(Ch3) + vexRT(Ch1);



		if(vexRT[Btn6D] == true){

			if(sensorValue[stopper] > 2900){

				motor[indexer]=80;
				motor[roller]=127;

				}else{

				motor[indexer]=-10;
				motor[roller]=127;

			}

			}else if( vexRT[Btn6U] == true){

			motor[indexer]=-127;
			motor[roller]=-127;



			}else{
			motor[indexer]=-0;
			motor[roller]=-0;

		}

		if(vexRT[Btn5U]){

			motor[indexer]=127;
			motor[roller]=127;



		}




		if (vexRT(Btn8U) == true) //ben controls = 7D
		{
			flywheelstate = true;
			goalvelocity = 390;

		}else
			if (vexRT(Btn8R) == true) //ben controls = 7D
		{
			flywheelstate = true;
			goalvelocity = 280;



		}else

		if (vexRT(Btn8L) == true) //ben controls = 7D
		{
			flywheelstate = false;
		}
		////////////////////////////////////////?





shoterror = goalvelocity - actualrpm;


if (vexRT(Btn7U) == true) //ben controls = 7D
{
	motor[descorer]=127;
}else
	if (vexRT(Btn7R) == true) //ben controls = 7D
{
	motor[descorer]=-127;

	}else{
	motor[descorer] = 0;

}




}
}
